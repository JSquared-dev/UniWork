/*****************************************************************************\
*
* $Workfile: Serial.c $
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
* 
* Copyright (c) 1998, 1999  Transpond Ltd
* 
* Module:   C sample application for N200.
*
* Abstract: Sample GNU generated application which are to be loaded
*           into the N200 using BootServer.  Note that the 
*           coff2bin utility converts the ARM executable COFF output files
*           generated by the GNU tools, into a Microsoft BIN format files.
* 
* Notes:    
*
* $History: Serial.c $
* 
* *****************  Version 1  *****************
* User: Rob          Date: 22/11/99   Time: 12:47
* Created in $/Wince212/Platform/N200/C_APP/lib
* 
* *****************  Version 1  *****************
* User: Rob          Date: 22/11/99   Time: 12:46
* Created in $/Wince212/Platform/N200/C_APP/C_APP/lib
*
\*****************************************************************************/


#include <bios/timer.h>
#include <bios/stdioint.h>

/*************************************
 *
 *      Main parameters.
 *
 ************************************/
/*
 * Serial port
 */
#ifndef UART_BASE

#define UART_BASE  SA1100_UART1_BASE

#endif /* UART_BASE */

/*************************************
 *
 *     Basic type definitions.
 *
 ************************************/
typedef    char                            S08;
typedef    unsigned char                   U08;
typedef    int                             S32;
typedef    unsigned int                    U32;
#define    NULL                            ((void *) 0)


/*************************************
 *
 *   SA1100 specific constants.
 *
 ************************************/
/* 
 * UART base addresses            
 */
#ifdef NO_MMU
    #define SA1100_UART1_BASE                  0x80010000
    #define SA1100_UART2_BASE                  0x80030000
    #define SA1100_UART3_BASE                  0x80050000
#else
    #define SA1100_UART1_BASE                  0xA8010000
    #define SA1100_UART2_BASE                  0xA8030000
    #define SA1100_UART3_BASE                  0xA8050000
#endif


/*
 * UART control registers 
 */
#define SA1100_UTCR0                       0x00
#define SA1100_UTCR1                       0x04
#define SA1100_UTCR2                       0x08
#define SA1100_UTCR3                       0x0C
#define SA1100_UTCR4                       0x10
#define SA1100_UTDR                        0x14
#define SA1100_UTSR0                       0x1C
#define SA1100_UTSR1                       0x20

/*
 * UART status definitions
 */
#define SA1100_UTSR1_TBY                   0x1   /*  transmitter busy flag         */
#define SA1100_UTSR1_RNE                   0x2   /*  receiver not empty (LSR_DR)   */
#define SA1100_UTSR1_TNF                   0x4   /*  transmit fifo non full        */
#define SA1100_UTSR1_PRE                   0x8   /*  parity read error (LSR_PE)    */
#define SA1100_UTSR1_FRE                   0x10  /*  framing error (LSR_FE)        */
#define SA1100_UTSR1_ROR                   0x20  /*  receive fifo overrun (LSR_OE) */

/*
 * UART Macros 
 */
#define UART_PUT_CHAR(p,c)                 ((*(volatile U32 *)(p + SA1100_UTDR)) = c)
#define UART_GET_STATUS(p)                 (*(volatile U32 *)(p + SA1100_UTSR1))
#define UART_GET_CHAR(p)                   (*(volatile U32 *)(p + SA1100_UTDR))
#define UART_RX_READY(s)                   ((s & SA1100_UTSR1_RNE) == SA1100_UTSR1_RNE)
#define UART_TX_READY(s)                   ((s & 4) != 0)

/*
 * OS timers
 */
#ifdef NO_MMU
    #define SA1100_OSMR0                       0x90000000
#else
    #define SA1100_OSMR0                       0xA9000000
#endif

#define SA1100_OSMR1                       (SA1100_OSMR0 + 0x04)
#define SA1100_OSMR2                       (SA1100_OSMR0 + 0x08)
#define SA1100_OSMR3                       (SA1100_OSMR0 + 0x0C)
#define SA1100_OSCR                        (SA1100_OSMR0 + 0x10)
#define SA1100_OSSR                        (SA1100_OSMR0 + 0x14)
#define SA1100_OWER                        (SA1100_OSMR0 + 0x18)
#define SA1100_OIER                        (SA1100_OSMR0 + 0x1C)

/*
 * GPIO registers
 */
#ifdef NO_MMU
    #define SA1100_GPIOREGBASE                 0x90040000
#else
    #define SA1100_GPIOREGBASE                 0xA9040000
#endif 

#define SA1100_GPLR                        0x00
#define SA1100_GPDR                        0x04
#define SA1100_GPSR                        0x08
#define SA1100_GPCR                        0x0C
#define SA1100_GRER                        0x10
#define SA1100_GFER                        0x14
#define SA1100_GEDR                        0x18
#define SA1100_GAFR                        0x1C


/***************************************************************************
*
* ser_init - set up serial port as follows:
*                        1 Stop bit
*                        8 Data bits
*                        No parity
*                        115200 Baud
*
***************************************************************************/
void ser_init(void)
{
    volatile U32*    pU32CR0   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTCR0);
    volatile U32*    pU32CR1   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTCR1);
    volatile U32*    pU32CR2   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTCR2);
    volatile U32*    pU32CR3   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTCR3);
    volatile U32*    pU32SR0   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTSR0);
    volatile U32*    pU32SR1   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTSR1);
    volatile U32*    pU32CR4   =  (U32 *)((U08 *)(UART_BASE) + SA1100_UTCR4);
    volatile U32*    pU32HSCR0 =  (U32 *)(0x80040060);
    volatile U32*    pSDCR0    =  (U32 *)(0x80020060);
    volatile U32*    pSDCR1    =  (U32 *)(0x80020064);
    
    /* Setup Serial port */

    /* Setup Serial port */
    if (UART_BASE == SA1100_UART1_BASE) 
    {
        /*
         * UART1 is an SDLC port or UART.
         * The following are required for UART operation 
         */
         /* Disable SDLC / enable UART. */
        *pSDCR0 = 0x00000001;
        *pSDCR1 = 0x00000000; 
    }
    else if (UART_BASE == SA1100_UART2_BASE) 
    {
        /* 
         * UART2 is an HSSP port or UART. 
         * The following are required for UART operation 
         */
        /* 1. Set HSSP control register 0 to 0x0 */
        *pU32HSCR0 =  0x0;
        /* 2. Set Control register 4 to 0x0 */
        *pU32CR4 = 0x0;
    }

    /* Wait for any pending transmissions to complete   */
    while(*pU32SR1 & 0x01);

    /* Disable rx, tx and interrupts - to reset line speed */
    *pU32CR3 = 0x0;    

    /* Clear status by writing 1's */
    *pU32SR0 = 0xFF;             

    /* 8 bit, no parity, 1 stop */
    *pU32CR0 = 0x08;     

    /* Set default baud rate, high byte & low byte */
    *pU32CR1 =     0x00;    /* upper baud rate select */
    *pU32CR2 = 1;        /* 1 == 115200 baud. 23 == 9600 baud */

    /* Enable rx and tx, NOT interrupts */
    *pU32CR3 = 0x03 ;            
} /* ser_init */


/***************************************************************************
*
* ser_read - Reads an array of characters from the serial port.
*
***************************************************************************/
int ser_read(char *buffer, int nr)
{
    int N = 0;
    while( N < nr)
    {
        unsigned long U32Status = UART_GET_STATUS(UART_BASE);

        while ( !UART_RX_READY(U32Status) )
        {
            U32Status = UART_GET_STATUS(UART_BASE);
            if (timer_poll(KEY_TIMER)) return -1;
        }
        *buffer++ = UART_GET_CHAR(UART_BASE);
        N++;
    }
    return N;
} /* ser_read */


/***************************************************************************
*
* ser_write - Writes an array of characters to the serial port.
*
***************************************************************************/
void ser_write(const char *buffer, int nr)
{
    int N = nr;

    while(N > 0)
    {
        char Ch = *buffer++;

        unsigned long U32Status;

        do 
        {
            U32Status = UART_GET_STATUS(UART_BASE);
        } 
        while (!UART_TX_READY(U32Status));


        UART_PUT_CHAR(UART_BASE, Ch);

        N--;
    }
} /* ser_write */


/***************************************************************************
*
* ser_stat - Reports the read status of the serial port.
*
***************************************************************************/
int ser_stat(void)
{
    unsigned long U32Status = UART_GET_STATUS(UART_BASE);
    return (int) UART_RX_READY(U32Status);
} /* ser_stat */
